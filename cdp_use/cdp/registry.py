# This file is auto-generated by the CDP protocol generator.
# Do not edit this file manually as your changes will be overwritten.
# Generated from Chrome DevTools Protocol specifications.

"""CDP Event Registry"""

import asyncio
import inspect
import logging
from typing import Any, Callable, Dict, List, Optional, Tuple, Union
from collections.abc import Awaitable

logger = logging.getLogger(__name__)

# Type alias for event handlers that can be sync or async
EventHandler = Union[
    Callable[[Any, Optional[str]], None],
    Callable[[Any, Optional[str]], Awaitable[None]],
]

class EventRegistry:
    """Central registry for managing CDP event callbacks."""

    def __init__(self):
        # Store handlers as list of (callback, is_once) tuples to support multiple listeners
        self._handlers: Dict[str, List[Tuple[EventHandler, bool]]] = {}

    def register(
        self,
        method: str,
        callback: EventHandler,
        once: bool = False,
    ) -> None:
        """
        Register a callback for a specific CDP event method.
        
        Args:
            method: The CDP method name (e.g., "Page.frameAttached")
            callback: Function to call when event occurs.
                     Receives (event_data, session_id) as parameters.
            once: If True, the callback will be automatically removed after first execution.
        """
        logger.debug(f"Registering handler for {method} (once={once})")
        if method not in self._handlers:
            self._handlers[method] = []
        self._handlers[method].append((callback, once))

    def unregister(
        self,
        method: str,
        callback: Optional[EventHandler] = None,
    ) -> None:
        """
        Unregister a callback for a specific CDP event method.
        
        Args:
            method: The CDP method name to unregister
            callback: Specific callback to remove. If None, removes all callbacks for this method.
        """
        if method not in self._handlers:
            return
        
        if callback is None:
            # Remove all handlers for this method
            logger.debug(f"Unregistering all handlers for {method}")
            del self._handlers[method]
        else:
            # Remove specific callback
            self._handlers[method] = [
                (cb, once) for cb, once in self._handlers[method]
                if cb != callback
            ]
            logger.debug(f"Unregistered specific handler for {method}")
            
            # Clean up empty list
            if not self._handlers[method]:
                del self._handlers[method]

    async def handle_event(
        self,
        method: str,
        params: Any,
        session_id: Optional[str] = None,
    ) -> bool:
        """
        Handle an incoming CDP event.
        
        Args:
            method: The CDP method name
            params: The event parameters
            session_id: Optional session ID
            
        Returns:
            True if a handler was found and called, False otherwise
        """
        if method not in self._handlers:
            return False
        
        # Track indices of one-time handlers to remove after execution
        handlers_to_remove = []
        
        for i, (handler, is_once) in enumerate(self._handlers[method]):
            try:
                # Check if handler is async
                if inspect.iscoroutinefunction(handler):
                    # Run handler in background to avoid blocking the message receive loop.
                    # Direct await would cause deadlock: handler waits for CDP response,
                    # but response cannot be received because message loop is blocked.
                    asyncio.create_task(handler(params, session_id))
                else:
                    # Call sync handlers directly
                    handler(params, session_id)
                
                # Mark one-time handler for removal
                if is_once:
                    handlers_to_remove.append(i)
            except Exception as e:
                logger.error(f"Error in event handler for {method}: {e}", exc_info=True)
        
        # Remove one-time handlers (iterate in reverse to avoid index issues)
        for i in reversed(handlers_to_remove):
            self._handlers[method].pop(i)
        
        # Clean up empty handler list
        if method in self._handlers and not self._handlers[method]:
            del self._handlers[method]
        
        return True

    def clear(self) -> None:
        """Clear all registered handlers."""
        logger.debug("Clearing all event handlers")
        self._handlers.clear()

    def get_registered_methods(self) -> list[str]:
        """Get a list of all registered method names."""
        return list(self._handlers.keys())
