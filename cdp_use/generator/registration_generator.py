"""
Registration generator for CDP protocol event registration.

Generates type-safe event registration interfaces for CDP domains.
"""

from typing import Any, Dict, List


class RegistrationGenerator:
    """Generates type-safe event registration interfaces for CDP domains."""

    def __init__(self):
        self.imports = set()
        self.type_checking_imports = set()

    def generate_registration(self, domain: Dict[str, Any]) -> str:
        """Generate registration.py content for a domain."""
        self.imports.clear()
        self.type_checking_imports.clear()

        domain_name = domain["domain"]
        events = domain.get("events", [])

        # Always add basic imports
        self.imports.add("from typing import Callable, Optional, Protocol, Union")
        self.imports.add("from collections.abc import Awaitable")

        # Start with auto-generated header
        content = """# This file is auto-generated by the CDP protocol generator.
# Do not edit this file manually as your changes will be overwritten.
# Generated from Chrome DevTools Protocol specifications.

"""
        content += f'"""CDP {domain_name} Domain Event Registration"""\n\n'

        # Generate registration interface and class
        if events:
            registration_content = self.generate_registration_class(domain_name, events)
            content += "\n".join(sorted(self.imports))
            content += "\n\n"

            # Add TYPE_CHECKING imports if any
            if self.type_checking_imports:
                content += "from typing import TYPE_CHECKING\n\n"
                content += "if TYPE_CHECKING:\n"
                for imp in sorted(self.type_checking_imports):
                    content += f"    {imp}\n"
                content += "\n"

            content += registration_content
        else:
            content += "\n".join(sorted(self.imports))
            content += "\n\n"
            content += "# No events defined for this domain"

        return content

    def generate_registration_class(
        self, domain_name: str, events: List[Dict[str, Any]]
    ) -> str:
        """Generate the registration class for a domain."""
        class_name = f"{domain_name}Registration"

        # Import specific events instead of *
        event_imports = []
        for event in events:
            event_class_name = self.to_class_name(event["name"]) + "Event"
            event_imports.append(event_class_name)

        if event_imports:
            # Split imports into multiple lines if too many
            if len(event_imports) <= 5:
                import_line = f"from .events import {', '.join(sorted(event_imports))}"
            else:
                import_line = "from .events import (\n"
                for i, event_import in enumerate(sorted(event_imports)):
                    import_line += f"    {event_import}"
                    if i < len(event_imports) - 1:
                        import_line += ","
                    import_line += "\n"
                import_line += ")"
            self.type_checking_imports.add(import_line)

        self.type_checking_imports.add("from ..registry import EventRegistry")

        content = f"class {class_name}:\n"
        content += (
            f'    """Event registration interface for {domain_name} domain."""\n\n'
        )
        content += "    def __init__(self, registry: 'EventRegistry'):\n"
        content += "        self._registry = registry\n"
        content += f'        self._domain = "{domain_name}"\n\n'

        # Generate registration methods for each event
        for event in events:
            event_method = self.generate_event_registration_method(event, domain_name)
            content += event_method + "\n"

        return content

    def generate_event_registration_method(
        self, event: Dict[str, Any], domain_name: str
    ) -> str:
        """Generate a registration method for a single event."""
        event_name = event["name"]
        method_name = event_name  # Use camelCase as in original CDP commands
        event_class_name = self.to_class_name(event_name) + "Event"
        cdp_method_name = f"{domain_name}.{event_name}"

        # Determine the callback type based on event parameters
        # Support both sync and async callbacks
        callback_type = (
            f"Union["
            f"Callable[['{event_class_name}', Optional[str]], None], "
            f"Callable[['{event_class_name}', Optional[str]], Awaitable[None]]"
            f"]"
        )

        # Generate main registration method with once parameter
        content = f"    def {method_name}(\n"
        content += "        self,\n"
        content += f"        callback: {callback_type},\n"
        content += "        once: bool = False,\n"
        content += "    ) -> None:\n"

        # Add docstring if event has description
        description = event.get("description", "")
        if description:
            escaped_desc = description.replace("\\", "\\\\").replace('"', '\\"')
            content += '        """\n'
            content += f"        Register a callback for {event_name} events.\n"
            content += "        \n"
            content += f"        {escaped_desc}\n"
            content += "        \n"
            content += "        Args:\n"
            content += "            callback: Function to call when event occurs.\n"
            content += "                     Receives (event_data, session_id) as parameters.\n"
            content += "            once: If True, callback will be removed after first execution.\n"
            content += '        """\n'
        else:
            content += '        """\n'
            content += f"        Register a callback for {event_name} events.\n"
            content += "        \n"
            content += "        Args:\n"
            content += "            callback: Function to call when event occurs.\n"
            content += "                     Receives (event_data, session_id) as parameters.\n"
            content += "            once: If True, callback will be removed after first execution.\n"
            content += '        """\n'

        content += f'        self._registry.register("{cdp_method_name}", callback, once)\n'

        return content

    def to_class_name(self, name: str) -> str:
        """Convert a CDP name to a Python class name."""
        # Convert camelCase to PascalCase
        if name and name[0].islower():
            name = name[0].upper() + name[1:]
        return name
