"""
Registry generator for CDP event registry.

Generates the central EventRegistry class that manages event callbacks.
"""

from typing import Any, Dict, List


class RegistryGenerator:
    """Generates the central EventRegistry class."""

    def generate_registry(self, domains: List[Dict[str, Any]]) -> str:
        """Generate the central registry.py file."""
        
        content = """# This file is auto-generated by the CDP protocol generator.
# Do not edit this file manually as your changes will be overwritten.
# Generated from Chrome DevTools Protocol specifications.

"""
        content += '"""CDP Event Registry"""\n\n'
        
        content += "import logging\n"
        content += "from typing import Any, Callable, Dict, Optional\n\n"
        
        content += "logger = logging.getLogger(__name__)\n\n"
        
        content += "class EventRegistry:\n"
        content += '    """Central registry for managing CDP event callbacks."""\n\n'
        content += "    def __init__(self):\n"
        content += "        self._handlers: Dict[str, Callable[[Any, Optional[str]], None]] = {}\n\n"
        
        content += "    def register(\n"
        content += "        self,\n"
        content += "        method: str,\n"
        content += "        callback: Callable[[Any, Optional[str]], None],\n"
        content += "    ) -> None:\n"
        content += '        """\n'
        content += '        Register a callback for a specific CDP event method.\n'
        content += '        \n'
        content += '        Args:\n'
        content += '            method: The CDP method name (e.g., "Page.frameAttached")\n'
        content += '            callback: Function to call when event occurs.\n'
        content += '                     Receives (event_data, session_id) as parameters.\n'
        content += '        """\n'
        content += '        logger.debug(f"Registering handler for {method}")\n'
        content += "        self._handlers[method] = callback\n\n"
        
        content += "    def unregister(self, method: str) -> None:\n"
        content += '        """\n'
        content += '        Unregister a callback for a specific CDP event method.\n'
        content += '        \n'
        content += '        Args:\n'
        content += '            method: The CDP method name to unregister\n'
        content += '        """\n'
        content += '        logger.debug(f"Unregistering handler for {method}")\n'
        content += "        self._handlers.pop(method, None)\n\n"
        
        content += "    async def handle_event(\n"
        content += "        self,\n"
        content += "        method: str,\n"
        content += "        params: Any,\n"
        content += "        session_id: Optional[str] = None,\n"
        content += "    ) -> bool:\n"
        content += '        """\n'
        content += '        Handle an incoming CDP event.\n'
        content += '        \n'
        content += '        Args:\n'
        content += '            method: The CDP method name\n'
        content += '            params: The event parameters\n'
        content += '            session_id: Optional session ID\n'
        content += '            \n'
        content += '        Returns:\n'
        content += '            True if a handler was found and called, False otherwise\n'
        content += '        """\n'
        content += "        if method in self._handlers:\n"
        content += "            try:\n"
        content += "                import asyncio\n"
        content += "                import inspect\n"
        content += "                handler = self._handlers[method]\n\n"
        content += "                # Check if handler is async\n"
        content += "                if inspect.iscoroutinefunction(handler):\n"
        content += "                    # Run handler in background to avoid blocking the message receive loop.\n"
        content += "                    # Direct await would cause deadlock: handler waits for CDP response,\n"
        content += "                    # but response cannot be received because message loop is blocked.\n"
        content += "                    asyncio.create_task(handler(params, session_id))\n"
        content += "                else:\n"
        content += "                    # Call sync handlers directly\n"
        content += "                    handler(params, session_id)\n"
        content += "                return True\n"
        content += "            except Exception as e:\n"
        content += '                logger.error(f"Error in event handler for {method}: {e}")\n'
        content += "                return False\n"
        content += "        return False\n\n"
        
        content += "    def clear(self) -> None:\n"
        content += '        """Clear all registered handlers."""\n'
        content += '        logger.debug("Clearing all event handlers")\n'
        content += "        self._handlers.clear()\n\n"
        
        content += "    def get_registered_methods(self) -> list[str]:\n"
        content += '        """Get a list of all registered method names."""\n'
        content += "        return list(self._handlers.keys())\n"
        
        return content